/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/tree.ts
function findParentForNode(ancestor, node) {
  if (ancestor.children.indexOf(node) >= 0) {
    return ancestor;
  }
  for (let i = 0; i < ancestor.children.length; i++) {
    const child = ancestor.children[i];
    const parent = findParentForNode(child, node);
    if (parent) {
      return parent;
    }
  }
  return null;
}
function treeFromLineInfos(lineInfos) {
  const root = { lineInfo: null, children: [] };
  let currentParent = root;
  function currentIndentation() {
    return currentParent.lineInfo ? currentParent.lineInfo.indentation + 1 : 0;
  }
  for (let i = 0; i < lineInfos.length; i++) {
    const lineInfo = lineInfos[i];
    const lineNode = { lineInfo, children: [] };
    if (lineInfo.indentation > currentIndentation()) {
      currentParent.children.push(lineNode);
    } else if (lineInfo.indentation < currentIndentation()) {
      while (lineInfo.indentation < currentIndentation()) {
        const parent = findParentForNode(root, currentParent);
        if (parent) {
          currentParent = parent;
        } else {
          throw new Error("Could not fund parent for node");
        }
      }
      currentParent.children.push(lineNode);
    } else {
      currentParent.children.push(lineNode);
    }
    currentParent = lineNode;
  }
  return root;
}
function lineInfosFromTree(root) {
  const lineInfos = [];
  function walk(node) {
    if (node.lineInfo) {
      lineInfos.push(node.lineInfo);
    }
    for (let i = 0; i < node.children.length; i++) {
      walk(node.children[i]);
    }
  }
  walk(root);
  return lineInfos;
}

// src/sort.ts
function sortTodos(plainText, sortOrder) {
  const lines = plainText.split("\n");
  const lineInfos = lines.map((value, originalIndex) => {
    const todo = value.indexOf("- [") >= 0;
    const completed = value.indexOf("- [x]") >= 0;
    const indentation = value.length - value.trimStart().length;
    return { originalIndex, value, todo, completed, indentation };
  });
  const sortedLineInfos = sortLineInfos(lineInfos, sortOrder);
  const lineMap = {};
  for (let i = 0; i < sortedLineInfos.length; i++) {
    const lineInfo = sortedLineInfos[i];
    lineMap[lineInfo.originalIndex] = i;
  }
  const output = sortedLineInfos.map((lineInfo) => lineInfo.value).join("\n");
  return { output, lineMap };
}
function sortLineInfos(lineInfos, sortOrder) {
  const tree = treeFromLineInfos(lineInfos);
  sortChildTodos(tree, sortOrder);
  return lineInfosFromTree(tree);
}
function sortChildTodos(node, sortOrder) {
  var _a;
  let currentGroup = 0;
  const groupMap = {};
  for (let i in node.children) {
    const child = node.children[i];
    if (!((_a = child.lineInfo) == null ? void 0 : _a.todo)) {
      currentGroup += 1;
    } else {
      groupMap[child.lineInfo.originalIndex] = currentGroup;
    }
  }
  node.children.sort((a, b) => {
    var _a2, _b, _c, _d;
    const aGroup = groupMap[a.lineInfo.originalIndex];
    const bGroup = groupMap[b.lineInfo.originalIndex];
    if (aGroup !== bGroup) {
      return aGroup - bGroup;
    }
    if (((_a2 = a.lineInfo) == null ? void 0 : _a2.completed) && !((_b = b.lineInfo) == null ? void 0 : _b.completed))
      return sortOrder == "completed-top" /* COMPLETED_TOP */ ? -1 : 1;
    if (!((_c = a.lineInfo) == null ? void 0 : _c.completed) && ((_d = b.lineInfo) == null ? void 0 : _d.completed))
      return sortOrder == "completed-top" /* COMPLETED_TOP */ ? 1 : -1;
    return 0;
  });
  for (let child of node.children) {
    sortChildTodos(child, sortOrder);
  }
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  sortOrder: "completed-top" /* COMPLETED_TOP */
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Todo sort" });
    new import_obsidian.Setting(containerEl).setName("Sort order").addDropdown((dropdown) => dropdown.addOption("completed-top" /* COMPLETED_TOP */, "Completed at top").addOption("completed-bottom" /* COMPLETED_BOTTOM */, "Completed at bottom").setValue(this.plugin.settings.sortOrder).onChange(async (val) => {
      this.plugin.settings.sortOrder = val;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this._onEditorChange = (editor, _markdownView) => {
      this._sortTodos(editor);
    };
    this._lastSort = new Date();
    this._lastValue = "";
    this._sortTodos = async (editor) => {
      const began = new Date();
      const value = editor.getValue();
      if (value === this._lastValue) {
        return;
      }
      if (new Date().getTime() - this._lastSort.getTime() < 100) {
        console.error("WARNING!!! Possible infinite sort detected");
        return;
      }
      await this.loadSettings();
      const cursor = editor.getCursor();
      const lineNumber = cursor.line;
      const result = sortTodos(value, this.settings.sortOrder);
      if (result.output !== value) {
        const now = new Date();
        console.log(`Sorted todos in ${now.getTime() - began.getTime()}ms`);
        this._lastSort = now;
        this._lastValue = result.output;
        editor.setValue(result.output);
        const newLine = result.lineMap[lineNumber];
        if (newLine != cursor.line) {
          editor.setCursor({
            line: newLine,
            ch: cursor.ch
          });
        }
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.registerEvent(this.app.workspace.on("editor-change", this._onEditorChange));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */